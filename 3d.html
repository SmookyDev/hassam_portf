<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kinect Point Cloud Effect</title>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
        }
        
        #kinect-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #kinect-video {
            display: none;
            /* hide raw video */
        }
        
        #kinect-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="kinect-container">
        <!-- The hidden video -->
        <video id="kinect-video" muted loop playsinline crossorigin="anonymous">
      <source src="assets/videos/1.mp4" type="video/webm" />
      <source src="assets/videos/1.mp4" type="video/mp4" />
    </video>

        <!-- Canvas for effect -->
        <canvas id="kinect-canvas"></canvas>
    </div>

    <!-- Vertex Shader -->
    <script id="vs" type="x-shader/x-vertex">
        uniform sampler2D map; uniform float width; uniform float height; uniform float nearClipping, farClipping; uniform float pointSize; uniform float zOffset; varying vec2 vUv; const float XtoZ = 1.11146; const float YtoZ = 0.83359; void main() { vUv = vec2(position.x
        / width, position.y / height); vec4 color = texture2D(map, vUv); float depth = (color.r + color.g + color.b) / 3.0; float z = (1.0 - depth) * (farClipping - nearClipping) + nearClipping; vec4 pos = vec4( (position.x / width - 0.5) * z * XtoZ,
        (position.y / height - 0.5) * z * YtoZ, -z + zOffset, 1.0 ); gl_PointSize = pointSize; gl_Position = projectionMatrix * modelViewMatrix * pos; }
    </script>

    <!-- Fragment Shader -->
    <script id="fs" type="x-shader/x-fragment">
        uniform sampler2D map; varying vec2 vUv; void main() { vec4 color = texture2D(map, vUv); gl_FragColor = vec4(color.r, color.g, color.b, 0.8); }
    </script>

    <!-- Main Script -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const container = document.getElementById("kinect-container");
            const video = document.getElementById("kinect-video");

            // Force autoplay (some browsers block it unless muted)
            video.muted = true;
            video.autoplay = true;
            video.loop = true;

            // Try playing video
            video.play().catch(err => {
                console.warn("Autoplay blocked. User interaction required:", err);
            });

            video.addEventListener("loadeddata", () => {
                console.log("Video ready, initializing effect...");

                let scene, camera, renderer;
                let geometry, mesh, material;
                let mouse, center;

                // Renderer
                renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById("kinect-canvas"),
                    alpha: true,
                    antialias: true
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(container.clientWidth, container.clientHeight);

                // Camera
                camera = new THREE.PerspectiveCamera(
                    50,
                    container.clientWidth / container.clientHeight,
                    1,
                    10000
                );
                camera.position.set(0, 0, 500);

                // Scene
                scene = new THREE.Scene();
                center = new THREE.Vector3(0, 0, -1000);

                // Texture
                const texture = new THREE.VideoTexture(video);
                texture.minFilter = THREE.NearestFilter;
                texture.generateMipmaps = false;

                const width = 640,
                    height = 480;
                const nearClipping = 850,
                    farClipping = 4000;

                // Geometry
                geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array(width * height * 3);
                for (let i = 0, j = 0, l = vertices.length; i < l; i += 3, j++) {
                    vertices[i] = j % width;
                    vertices[i + 1] = Math.floor(j / width);
                }
                geometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

                // Material with shaders
                material = new THREE.ShaderMaterial({
                    uniforms: {
                        map: {
                            value: texture
                        },
                        width: {
                            value: width
                        },
                        height: {
                            value: height
                        },
                        nearClipping: {
                            value: nearClipping
                        },
                        farClipping: {
                            value: farClipping
                        },
                        pointSize: {
                            value: 2
                        },
                        zOffset: {
                            value: 1000
                        }
                    },
                    vertexShader: document.getElementById("vs").textContent,
                    fragmentShader: document.getElementById("fs").textContent,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    depthWrite: false,
                    transparent: true
                });

                // Mesh
                mesh = new THREE.Points(geometry, material);
                scene.add(mesh);

                // Mouse interaction
                mouse = new THREE.Vector3(0, 0, 1);
                document.addEventListener("mousemove", onDocumentMouseMove);

                function onDocumentMouseMove(event) {
                    const rect = container.getBoundingClientRect();
                    mouse.x = (event.clientX - rect.left - container.clientWidth / 2) * 8;
                    mouse.y = (event.clientY - rect.top - container.clientHeight / 2) * 8;
                }

                // Resize
                window.addEventListener("resize", onWindowResize);

                function onWindowResize() {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                }

                // Animate
                function animate() {
                    requestAnimationFrame(animate);

                    camera.position.x += (mouse.x - camera.position.x) * 0.05;
                    camera.position.y += (-mouse.y - camera.position.y) * 0.05;
                    camera.lookAt(center);

                    renderer.render(scene, camera);
                }

                animate();
            });
        });
    </script>
</body>

</html>