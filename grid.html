<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flocking Birds Simulation</title>
    <style>        
        
        .simulation-container {
            width: 100%;
            height: 70vh;
            position: relative;
        }
        
        #simulation {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .simulation-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            max-width: 400px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin-top: 1.5rem;
            gap: 1rem;
        }
        
        .btn {
            padding: 0.8rem 1.5rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #2980b9;
        }


        @media (max-width: 768px) {
            .simulation-overlay {
                position: relative;
                bottom: 0;
                left: 0;
                width: 100%;
                max-width: none;
                border-radius: 0;
            }
        }
    </style>
</head>
<body>

    

    
    <section id="simulation-section" class="flocking-section">
        <div class="simulation-container">
            <div id="simulation"></div>
            <div class="simulation-overlay">
                <h3>Flocking Simulation</h3>
                <p>Move your cursor to influence the birds' flight pattern. The simulation uses GPU acceleration for realistic behavior.</p>
                <div class="controls">
                    <button class="btn" id="pause-btn">Pause</button>
                    <button class="btn" id="reset-btn">Reset</button>
                </div>
            </div>
        </div>
    </section>
    
    <!-- Three.js and related libraries -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import with correct paths using the importmap
        import * as THREE from 'three';
        import Stats from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/stats.module.js';
        import { GUI } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/lil-gui.module.min.js';
        import { GPUComputationRenderer } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/misc/GPUComputationRenderer.js';

        const WIDTH = 32;
        const BIRDS = WIDTH * WIDTH;

        class BirdGeometry extends THREE.BufferGeometry {
            constructor() {
                super();
                const trianglesPerBird = 3;
                const triangles = BIRDS * trianglesPerBird;
                const points = triangles * 3;

                const vertices = new THREE.BufferAttribute(new Float32Array(points * 3), 3);
                const birdColors = new THREE.BufferAttribute(new Float32Array(points * 3), 3);
                const references = new THREE.BufferAttribute(new Float32Array(points * 2), 2);
                const birdVertex = new THREE.BufferAttribute(new Float32Array(points), 1);

                this.setAttribute('position', vertices);
                this.setAttribute('birdColor', birdColors);
                this.setAttribute('reference', references);
                this.setAttribute('birdVertex', birdVertex);

                let v = 0;
                function verts_push(...args) {
                    for (let i = 0; i < args.length; i++) {
                        vertices.array[v++] = args[i];
                    }
                }

                const wingsSpan = 20;
                for (let f = 0; f < BIRDS; f++) {
                    verts_push(0, -0, -20, 0, 4, -20, 0, 0, 30);
                    verts_push(0, 0, -15, -wingsSpan, 0, 0, 0, 0, 15);
                    verts_push(0, 0, 15, wingsSpan, 0, 0, 0, 0, -15);
                }

                for (let i = 0; i < triangles * 3; i++) {
                    const triangleIndex = ~~(i / 3);
                    const birdIndex = ~~(triangleIndex / trianglesPerBird);
                    const x = (birdIndex % WIDTH) / WIDTH;
                    const y = ~~(birdIndex / WIDTH) / WIDTH;

                    const c = new THREE.Color(0x666666 + ~~(i / 9) / BIRDS * 0x666666);
                    birdColors.array[i * 3 + 0] = c.r;
                    birdColors.array[i * 3 + 1] = c.g;
                    birdColors.array[i * 3 + 2] = c.b;

                    references.array[i * 2] = x;
                    references.array[i * 2 + 1] = y;

                    birdVertex.array[i] = i % 9;
                }

                this.scale(0.2, 0.2, 0.2);
            }
        }

        let container, stats;
        let camera, scene, renderer;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        const BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;
        let last = performance.now();

        let gpuCompute;
        let velocityVariable, positionVariable;
        let positionUniforms, velocityUniforms, birdUniforms;
        
        let animationId = null;
        let isPaused = false;

        init();

        function init() {
            container = document.getElementById('simulation');
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 1, 3000);
            camera.position.z = 350;

            // Set up scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 100, 1000);

            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            initComputeRenderer();

            // Set up stats
            stats = new Stats();
            stats.dom.style.position = 'absolute';
            stats.dom.style.top = '10px';
            stats.dom.style.right = '10px';
            container.appendChild(stats.dom);

            // Handle mouse movement
            container.addEventListener('pointermove', onPointerMove);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Set up control buttons
            document.getElementById('pause-btn').addEventListener('click', togglePause);
            document.getElementById('reset-btn').addEventListener('click', resetSimulation);

            initBirds();
            animate();
        }
        
        function onWindowResize() {
            const container = document.getElementById('simulation');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function initComputeRenderer() {
            gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);

            const dtPosition = gpuCompute.createTexture();
            const dtVelocity = gpuCompute.createTexture();

            fillPositionTexture(dtPosition);
            fillVelocityTexture(dtVelocity);

            velocityVariable = gpuCompute.addVariable('textureVelocity',
                document.getElementById('fragmentShaderVelocity').textContent, dtVelocity);
            positionVariable = gpuCompute.addVariable('texturePosition',
                document.getElementById('fragmentShaderPosition').textContent, dtPosition);

            gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);
            gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);

            positionUniforms = positionVariable.material.uniforms;
            velocityUniforms = velocityVariable.material.uniforms;

            positionUniforms['time'] = { value: 0.0 };
            positionUniforms['delta'] = { value: 0.0 };
            velocityUniforms['time'] = { value: 1.0 };
            velocityUniforms['delta'] = { value: 0.0 };
            velocityUniforms['testing'] = { value: 1.0 };
            velocityUniforms['separationDistance'] = { value: 20.0 };
            velocityUniforms['alignmentDistance'] = { value: 20.0 };
            velocityUniforms['cohesionDistance'] = { value: 20.0 };
            velocityUniforms['freedomFactor'] = { value: 0.75 };
            velocityUniforms['predator'] = { value: new THREE.Vector3() };

            velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed(2);

            velocityVariable.wrapS = THREE.RepeatWrapping;
            velocityVariable.wrapT = THREE.RepeatWrapping;
            positionVariable.wrapS = THREE.RepeatWrapping;
            positionVariable.wrapT = THREE.RepeatingWrapping;

            const error = gpuCompute.init();
            if (error !== null) console.error(error);
        }

        function initBirds() {
            const geometry = new BirdGeometry();
            birdUniforms = {
                'color': { value: new THREE.Color(0xff2200) },
                'texturePosition': { value: null },
                'textureVelocity': { value: null },
                'time': { value: 1.0 },
                'delta': { value: 0.0 }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: birdUniforms,
                vertexShader: document.getElementById('birdVS').textContent,
                fragmentShader: document.getElementById('birdFS').textContent,
                side: THREE.DoubleSide
            });

            const birdMesh = new THREE.Mesh(geometry, material);
            birdMesh.rotation.y = Math.PI / 2;
            birdMesh.matrixAutoUpdate = false;
            birdMesh.updateMatrix();
            scene.add(birdMesh);
        }

        function fillPositionTexture(texture) {
            const theArray = texture.image.data;
            for (let k = 0, kl = theArray.length; k < kl; k += 4) {
                const x = Math.random() * BOUNDS - BOUNDS_HALF;
                const y = Math.random() * BOUNDS - BOUNDS_HALF;
                const z = Math.random() * BOUNDS - BOUNDS_HALF;
                theArray[k + 0] = x;
                theArray[k + 1] = y;
                theArray[k + 2] = z;
                theArray[k + 3] = 1;
            }
        }

        function fillVelocityTexture(texture) {
            const theArray = texture.image.data;
            for (let k = 0, kl = theArray.length; k < kl; k += 4) {
                const x = Math.random() - 0.5;
                const y = Math.random() - 0.5;
                const z = Math.random() - 0.5;
                theArray[k + 0] = x * 10;
                theArray[k + 1] = y * 10;
                theArray[k + 2] = z * 10;
                theArray[k + 3] = 1;
            }
        }

        function onPointerMove(event) {
            if (event.isPrimary === false) return;
            
            const rect = container.getBoundingClientRect();
            mouseX = event.clientX - rect.left - container.clientWidth / 2;
            mouseY = event.clientY - rect.top - container.clientHeight / 2;
        }
        
        function togglePause() {
            isPaused = !isPaused;
            const btn = document.getElementById('pause-btn');
            btn.textContent = isPaused ? 'Resume' : 'Pause';
            
            if (!isPaused) {
                animate();
            }
        }
        
        function resetSimulation() {
            initComputeRenderer();
        }

        function animate() {
            if (isPaused) return;
            
            animationId = requestAnimationFrame(animate);
            render();
            stats.update();
        }

        function render() {
            const now = performance.now();
            let delta = (now - last) / 1000;
            if (delta > 1) delta = 1;
            last = now;

            positionUniforms['time'].value = now;
            positionUniforms['delta'].value = delta;
            velocityUniforms['time'].value = now;
            velocityUniforms['delta'].value = delta;
            birdUniforms['time'].value = now;
            birdUniforms['delta'].value = delta;

            velocityUniforms['predator'].value.set(
                0.5 * mouseX / (container.clientWidth / 2),
                -0.5 * mouseY / (container.clientHeight / 2),
                0
            );

            mouseX = 10000;
            mouseY = 10000;

            gpuCompute.compute();

            birdUniforms['texturePosition'].value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
            birdUniforms['textureVelocity'].value = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;

            renderer.render(scene, camera);
        }
    </script>

    <!-- Shaders -->
    <script id="fragmentShaderPosition" type="x-shader/x-fragment">
        uniform float time;
        uniform float delta;
        void main() {
            vec2 uv = gl_FragCoord.xy / resolution.xy;
            vec4 tmpPos = texture2D(texturePosition, uv);
            vec3 position = tmpPos.xyz;
            vec3 velocity = texture2D(textureVelocity, uv).xyz;
            float phase = tmpPos.w;
            phase = mod((phase + delta + length(velocity.xz) * delta * 3. + max(velocity.y, 0.0) * delta * 6.), 62.83);
            gl_FragColor = vec4(position + velocity * delta * 15., phase);
        }
    </script>

    <script id="fragmentShaderVelocity" type="x-shader/x-fragment">
        uniform float time;
        uniform float testing;
        uniform float delta;
        uniform float separationDistance;
        uniform float alignmentDistance;
        uniform float cohesionDistance;
        uniform float freedomFactor;
        uniform vec3 predator;

        const float PI = 3.141592653589793;
        const float PI_2 = PI * 2.0;

        void main() {
            float zoneRadius = separationDistance + alignmentDistance + cohesionDistance;
            float separationThresh = separationDistance / zoneRadius;
            float alignmentThresh = (separationDistance + alignmentDistance) / zoneRadius;
            float zoneRadiusSquared = zoneRadius * zoneRadius;

            vec2 uv = gl_FragCoord.xy / resolution.xy;
            vec3 selfPosition = texture2D(texturePosition, uv).xyz;
            vec3 selfVelocity = texture2D(textureVelocity, uv).xyz;

            vec3 velocity = selfVelocity;
            float limit = 9.0;

            // Predator avoidance
            vec3 dir = predator * BOUNDS - selfPosition;
            dir.z = 0.;
            float dist = length(dir);
            float distSquared = dist * dist;
            float preyRadius = 150.0;
            float preyRadiusSq = preyRadius * preyRadius;

            if (dist < preyRadius) {
                float f = (distSquared / preyRadiusSq - 1.0) * delta * 100.;
                velocity += normalize(dir) * f;
                limit += 5.0;
            }

            // Move towards center
            vec3 central = vec3(0., 0., 0.);
            dir = selfPosition - central;
            dist = length(dir);
            dir.y *= 2.5;
            velocity -= normalize(dir) * delta * 5.;

            // Flocking
            for (float y = 0.0; y < resolution.y; y++) {
                for (float x = 0.0; x < resolution.x; x++) {
                    vec2 ref = vec2(x + 0.5, y + 0.5) / resolution.xy;
                    vec3 birdPosition = texture2D(texturePosition, ref).xyz;
                    dir = birdPosition - selfPosition;
                    dist = length(dir);
                    if (dist < 0.0001) continue;

                    float distSquaredLocal = dist * dist;
                    if (distSquaredLocal > zoneRadiusSquared) continue;

                    float percent = distSquaredLocal / zoneRadiusSquared;

                    if (percent < separationThresh) {
                        float f = (separationThresh / percent - 1.0) * delta;
                        velocity -= normalize(dir) * f;
                    } else if (percent < alignmentThresh) {
                        float threshDelta = alignmentThresh - separationThresh;
                        float adjustedPercent = (percent - separationThresh) / threshDelta;
                        vec3 birdVelocity = texture2D(textureVelocity, ref).xyz;
                        float f = (0.5 - cos(adjustedPercent * PI_2) * 0.5 + 0.5) * delta;
                        velocity += normalize(birdVelocity) * f;
                    } else {
                        float threshDelta = 1.0 - alignmentThresh;
                        float adjustedPercent = (threshDelta == 0.0) ? 1.0 : (percent - alignmentThresh) / threshDelta;
                        float f = (0.5 - (cos(adjustedPercent * PI_2) * -0.5 + 0.5)) * delta;
                        velocity += normalize(dir) * f;
                    }
                }
            }

            // Limit speed
            if (length(velocity) > limit) {
                velocity = normalize(velocity) * limit;
            }

            gl_FragColor = vec4(velocity, 1.0);
        }
    </script>

    <script type="x-shader/x-vertex" id="birdVS">
        attribute vec2 reference;
        attribute float birdVertex;
        attribute vec3 birdColor;
        uniform sampler2D texturePosition;
        uniform sampler2D textureVelocity;
        uniform float time;
        varying vec4 vColor;
        varying float z;
        void main() {
            vec4 tmpPos = texture2D(texturePosition, reference);
            vec3 pos = tmpPos.xyz;
            vec3 velocity = normalize(texture2D(textureVelocity, reference).xyz);
            vec3 newPosition = position;

            if (birdVertex == 4.0 || birdVertex == 7.0) {
                newPosition.y = sin(tmpPos.w) * 5.;
            }

            newPosition = mat3(modelMatrix) * newPosition;
            velocity.z *= -1.;

            float xz = length(velocity.xz);
            float x = sqrt(1. - velocity.y * velocity.y);

            float cosry = velocity.x / xz;
            float sinry = velocity.z / xz;
            float cosrz = x;
            float sinrz = velocity.y;

            mat3 maty = mat3(cosry, 0, -sinry, 0, 1, 0, sinry, 0, cosry);
            mat3 matz = mat3(cosrz, sinrz, 0, -sinrz, cosrz, 0, 0, 0, 1);

            newPosition = maty * matz * newPosition;
            newPosition += pos;

            z = newPosition.z;
            vColor = vec4(birdColor, 1.0);

            gl_Position = projectionMatrix * viewMatrix * vec4(newPosition, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="birdFS">
        varying vec4 vColor;
        varying float z;
        uniform vec3 color;
        void main() {
            float z2 = 0.2 + (1000. - z) / 1000. * vColor.x;
            gl_FragColor = vec4(z2, z2, z2, 1.0);
        }
    </script>
</body>
</html>